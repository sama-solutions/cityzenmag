import type { Thread } from '../types/database'\nimport type { Interview } from '../types/interviews'\nimport type { PhotoReport } from '../types/photoReports'\nimport type { VideoAnalysis } from '../types/videoAnalyses'\nimport type { Testimonial } from '../types/testimonials'\n\n// Types pour la recherche unifiée\nexport interface SearchResult {\n  id: string\n  type: 'thread' | 'interview' | 'reportage' | 'video' | 'testimonial'\n  title: string\n  description: string\n  content?: string\n  date: string\n  theme?: string\n  location?: string\n  author?: string\n  image?: string\n  url: string\n  relevanceScore: number\n  highlights: string[]\n}\n\nexport interface SearchFilters {\n  types?: string[]\n  dateRange?: {\n    start?: string\n    end?: string\n  }\n  themes?: string[]\n  locations?: string[]\n  authors?: string[]\n}\n\nexport interface SearchOptions {\n  query: string\n  filters?: SearchFilters\n  limit?: number\n  offset?: number\n  sortBy?: 'relevance' | 'date' | 'popularity'\n}\n\nexport interface SearchResponse {\n  results: SearchResult[]\n  total: number\n  suggestions: string[]\n  facets: {\n    types: { [key: string]: number }\n    themes: { [key: string]: number }\n    locations: { [key: string]: number }\n    authors: { [key: string]: number }\n  }\n  query: string\n  executionTime: number\n}\n\nclass SearchService {\n  private searchIndex: Map<string, SearchResult> = new Map()\n  private searchHistory: string[] = []\n  private popularQueries: Map<string, number> = new Map()\n\n  constructor() {\n    this.loadSearchHistory()\n  }\n\n  // Normaliser le texte : supprimer accents, caractères spéciaux et convertir en minuscules\n  private normalizeText(text: string): string {\n    if (!text) return ''\n    \n    return text\n      // Convertir en minuscules\n      .toLowerCase()\n      // Supprimer les accents français\n      .normalize('NFD')\n      .replace(/[\\u0300-\\u036f]/g, '')\n      // Remplacer les caractères spéciaux par des espaces\n      .replace(/[^a-z0-9\\s]/gi, ' ')\n      // Normaliser les espaces multiples\n      .replace(/\\s+/g, ' ')\n      .trim()\n  }\n\n  // Créer une version normalisée pour la recherche\n  private createSearchableText(item: SearchResult): string {\n    const textParts = [\n      item.title,\n      item.description,\n      item.content || '',\n      item.theme || '',\n      item.location || '',\n      item.author || ''\n    ]\n    \n    return this.normalizeText(textParts.join(' '))\n  }\n\n  // Échapper les caractères spéciaux pour regex\n  private escapeRegex(text: string): string {\n    return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  }\n\n  // Indexer tous les contenus pour la recherche\n  indexContent(\n    threads: Thread[],\n    interviews: Interview[],\n    reportages: PhotoReport[],\n    videos: VideoAnalysis[],\n    testimonials: Testimonial[]\n  ) {\n    this.searchIndex.clear()\n\n    // Indexer les threads Twitter\n    threads.forEach(thread => {\n      const result: SearchResult = {\n        id: thread.thread_id,\n        type: 'thread',\n        title: thread.title,\n        description: thread.description || '',\n        date: thread.date_created,\n        theme: thread.theme,\n        url: `/thread/${thread.thread_id}`,\n        relevanceScore: 0,\n        highlights: []\n      }\n      this.searchIndex.set(`thread-${thread.thread_id}`, result)\n    })\n\n    // Indexer les interviews\n    interviews.forEach(interview => {\n      const result: SearchResult = {\n        id: interview.id,\n        type: 'interview',\n        title: interview.title,\n        description: interview.description || '',\n        content: interview.transcript || interview.questions?.map(q => q.answer).join(' ') || '',\n        date: interview.publishedAt,\n        theme: interview.category,\n        author: interview.interviewee.name,\n        image: interview.interviewee.photo || interview.thumbnail,\n        url: `/interviews#${interview.id}`,\n        relevanceScore: 0,\n        highlights: []\n      }\n      this.searchIndex.set(`interview-${interview.id}`, result)\n    })\n\n    // Indexer les reportages photo\n    reportages.forEach(reportage => {\n      const result: SearchResult = {\n        id: reportage.id,\n        type: 'reportage',\n        title: reportage.title,\n        description: reportage.description,\n        content: reportage.images?.map(img => img.caption).join(' ') || '',\n        date: reportage.publishedAt,\n        theme: reportage.category,\n        location: reportage.location.name,\n        author: reportage.photographer.name,\n        image: reportage.coverImage,\n        url: `/reportages#${reportage.id}`,\n        relevanceScore: 0,\n        highlights: []\n      }\n      this.searchIndex.set(`reportage-${reportage.id}`, result)\n    })\n\n    // Indexer les vidéos analyses\n    videos.forEach(video => {\n      const result: SearchResult = {\n        id: video.id,\n        type: 'video',\n        title: video.title,\n        description: video.description || '',\n        content: video.transcript || video.chapters?.map(c => c.title).join(' ') || '',\n        date: video.publishedAt,\n        theme: video.category,\n        author: video.speaker.name,\n        image: video.thumbnail,\n        url: `/videos#${video.id}`,\n        relevanceScore: 0,\n        highlights: []\n      }\n      this.searchIndex.set(`video-${video.id}`, result)\n    })\n\n    // Indexer les témoignages\n    testimonials.forEach(testimonial => {\n      const result: SearchResult = {\n        id: testimonial.id,\n        type: 'testimonial',\n        title: testimonial.title,\n        description: testimonial.content,\n        content: testimonial.content,\n        date: testimonial.createdAt,\n        theme: testimonial.category,\n        location: testimonial.author.location,\n        author: testimonial.author.anonymous ? 'Anonyme' : testimonial.author.name,\n        url: `/temoignages#${testimonial.id}`,\n        relevanceScore: 0,\n        highlights: []\n      }\n      this.searchIndex.set(`testimonial-${testimonial.id}`, result)\n    })\n  }\n\n  // Recherche principale\n  async search(options: SearchOptions): Promise<SearchResponse> {\n    const startTime = Date.now()\n    const { query, filters = {}, limit = 20, offset = 0, sortBy = 'relevance' } = options\n\n    // Enregistrer la recherche\n    this.recordSearch(query)\n\n    // Recherche full-text\n    const results = this.performFullTextSearch(query, filters)\n\n    // Trier les résultats\n    const sortedResults = this.sortResults(results, sortBy)\n\n    // Pagination\n    const paginatedResults = sortedResults.slice(offset, offset + limit)\n\n    // Générer les facettes\n    const facets = this.generateFacets(results)\n\n    // Générer les suggestions\n    const suggestions = this.generateSuggestions(query)\n\n    const executionTime = Date.now() - startTime\n\n    return {\n      results: paginatedResults,\n      total: results.length,\n      suggestions,\n      facets,\n      query,\n      executionTime\n    }\n  }\n\n  // Recherche full-text\n  private performFullTextSearch(query: string, filters: SearchFilters): SearchResult[] {\n    // Normaliser la requête de recherche\n    const normalizedQuery = this.normalizeText(query)\n    const queryTerms = normalizedQuery.split(/\\s+/).filter(term => term.length > 2)\n    const results: SearchResult[] = []\n\n    for (const [key, item] of this.searchIndex) {\n      // Appliquer les filtres\n      if (!this.matchesFilters(item, filters)) {\n        continue\n      }\n\n      // Calculer le score de pertinence avec texte normalisé\n      const score = this.calculateRelevanceScore(item, queryTerms, query)\n      \n      if (score > 0) {\n        const result = { ...item }\n        result.relevanceScore = score\n        result.highlights = this.generateHighlights(item, queryTerms, query)\n        results.push(result)\n      }\n    }\n\n    return results\n  }\n\n  // Calculer le score de pertinence\n  private calculateRelevanceScore(item: SearchResult, queryTerms: string[], originalQuery: string): number {\n    let score = 0\n    \n    // Créer les versions normalisées pour la comparaison\n    const normalizedTitle = this.normalizeText(item.title)\n    const normalizedDescription = this.normalizeText(item.description)\n    const normalizedContent = this.normalizeText(item.content || '')\n    const searchableText = this.createSearchableText(item)\n    const normalizedFullQuery = this.normalizeText(originalQuery)\n\n    queryTerms.forEach(term => {\n      // Score pour le titre (poids 3)\n      if (normalizedTitle.includes(term)) {\n        score += 3\n      }\n\n      // Score pour la description (poids 2)\n      if (normalizedDescription.includes(term)) {\n        score += 2\n      }\n\n      // Score pour le contenu (poids 1)\n      if (normalizedContent.includes(term)) {\n        score += 1\n      }\n\n      // Score pour les autres champs (poids 0.5)\n      if (searchableText.includes(term)) {\n        score += 0.5\n      }\n    })\n\n    // Bonus pour correspondance exacte de la requête complète\n    if (searchableText.includes(normalizedFullQuery)) {\n      score += 5\n    }\n\n    // Bonus pour correspondance partielle de mots multiples\n    if (queryTerms.length > 1) {\n      const foundTerms = queryTerms.filter(term => searchableText.includes(term))\n      if (foundTerms.length === queryTerms.length) {\n        score += 2 // Bonus si tous les termes sont trouvés\n      }\n    }\n\n    return score\n  }\n\n  // Vérifier si l'item correspond aux filtres\n  private matchesFilters(item: SearchResult, filters: SearchFilters): boolean {\n    // Filtre par type\n    if (filters.types && filters.types.length > 0) {\n      if (!filters.types.includes(item.type)) {\n        return false\n      }\n    }\n\n    // Filtre par date\n    if (filters.dateRange) {\n      const itemDate = new Date(item.date)\n      if (filters.dateRange.start && itemDate < new Date(filters.dateRange.start)) {\n        return false\n      }\n      if (filters.dateRange.end && itemDate > new Date(filters.dateRange.end)) {\n        return false\n      }\n    }\n\n    // Filtre par thème\n    if (filters.themes && filters.themes.length > 0) {\n      if (!item.theme || !filters.themes.includes(item.theme)) {\n        return false\n      }\n    }\n\n    // Filtre par lieu\n    if (filters.locations && filters.locations.length > 0) {\n      if (!item.location || !filters.locations.includes(item.location)) {\n        return false\n      }\n    }\n\n    // Filtre par auteur\n    if (filters.authors && filters.authors.length > 0) {\n      if (!item.author || !filters.authors.includes(item.author)) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  // Trier les résultats\n  private sortResults(results: SearchResult[], sortBy: string): SearchResult[] {\n    switch (sortBy) {\n      case 'date':\n        return results.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())\n      case 'popularity':\n        // Simuler la popularité basée sur le type et la date\n        return results.sort((a, b) => {\n          const aPopularity = this.getPopularityScore(a)\n          const bPopularity = this.getPopularityScore(b)\n          return bPopularity - aPopularity\n        })\n      case 'relevance':\n      default:\n        return results.sort((a, b) => b.relevanceScore - a.relevanceScore)\n    }\n  }\n\n  // Score de popularité simulé\n  private getPopularityScore(item: SearchResult): number {\n    const typeScores = {\n      thread: 1,\n      interview: 3,\n      reportage: 2,\n      video: 4,\n      testimonial: 2\n    }\n    \n    const daysSincePublication = Math.floor(\n      (Date.now() - new Date(item.date).getTime()) / (1000 * 60 * 60 * 24)\n    )\n    \n    return (typeScores[item.type] || 1) * Math.max(1, 30 - daysSincePublication)\n  }\n\n  // Générer les highlights\n  private generateHighlights(item: SearchResult, queryTerms: string[], originalQuery: string): string[] {\n    const highlights: string[] = []\n    const text = item.description\n    const normalizedText = this.normalizeText(text)\n    \n    // Essayer de trouver les highlights avec les termes originaux d'abord\n    const originalTerms = originalQuery.toLowerCase().split(/\\s+/).filter(term => term.length > 2)\n    \n    // Fonction pour trouver les highlights avec flexibilité sur les accents\n    const findHighlights = (searchTerms: string[], isNormalized: boolean = false) => {\n      searchTerms.forEach(term => {\n        const searchText = isNormalized ? normalizedText : text.toLowerCase()\n        const searchTerm = isNormalized ? this.normalizeText(term) : term.toLowerCase()\n        \n        const index = searchText.indexOf(searchTerm)\n        if (index !== -1) {\n          const start = Math.max(0, index - 50)\n          const end = Math.min(text.length, index + term.length + 50)\n          const context = text.substring(start, end)\n          \n          // Créer le highlight en préservant la casse originale\n          const highlightRegex = new RegExp(`(${this.escapeRegex(term)})`, 'gi')\n          const highlighted = context.replace(highlightRegex, '<mark>$1</mark>')\n          \n          if (!highlights.some(h => h.includes(highlighted.replace(/<\\/?mark>/g, '')))) {\n            highlights.push(highlighted)\n          }\n        }\n      })\n    }\n    \n    // Essayer d'abord avec les termes originaux\n    findHighlights(originalTerms)\n    \n    // Si pas assez de highlights, essayer avec les termes normalisés\n    if (highlights.length < 2) {\n      findHighlights(queryTerms, true)\n    }\n\n    return highlights.slice(0, 3) // Limiter à 3 highlights\n  }\n\n  // Générer les facettes\n  private generateFacets(results: SearchResult[]) {\n    const facets = {\n      types: {} as { [key: string]: number },\n      themes: {} as { [key: string]: number },\n      locations: {} as { [key: string]: number },\n      authors: {} as { [key: string]: number }\n    }\n\n    results.forEach(result => {\n      // Types\n      facets.types[result.type] = (facets.types[result.type] || 0) + 1\n\n      // Thèmes\n      if (result.theme) {\n        facets.themes[result.theme] = (facets.themes[result.theme] || 0) + 1\n      }\n\n      // Lieux\n      if (result.location) {\n        facets.locations[result.location] = (facets.locations[result.location] || 0) + 1\n      }\n\n      // Auteurs\n      if (result.author) {\n        facets.authors[result.author] = (facets.authors[result.author] || 0) + 1\n      }\n    })\n\n    return facets\n  }\n\n  // Générer les suggestions\n  private generateSuggestions(query: string): string[] {\n    const suggestions: string[] = []\n    const normalizedQuery = this.normalizeText(query)\n    \n    // Suggestions basées sur les recherches populaires\n    for (const [popularQuery, count] of this.popularQueries) {\n      const normalizedPopular = this.normalizeText(popularQuery)\n      if (normalizedPopular.includes(normalizedQuery) && popularQuery !== query) {\n        suggestions.push(popularQuery)\n      }\n    }\n\n    // Suggestions basées sur le contenu indexé avec accents\n    const contentSuggestions = [\n      'transparence gouvernementale',\n      'corruption Sénégal',\n      'modernisation administration',\n      'accès information publique',\n      'gouvernance locale',\n      'participation citoyenne',\n      'réformes institutionnelles',\n      'digitalisation services',\n      'démocratie participative',\n      'contrôle citoyen',\n      'éthique publique',\n      'responsabilité gouvernementale'\n    ]\n\n    contentSuggestions.forEach(suggestion => {\n      const normalizedSuggestion = this.normalizeText(suggestion)\n      if (normalizedSuggestion.includes(normalizedQuery) && !suggestions.includes(suggestion)) {\n        suggestions.push(suggestion)\n      }\n    })\n\n    return suggestions.slice(0, 5)\n  }\n\n  // Enregistrer une recherche\n  private recordSearch(query: string) {\n    if (query.trim().length > 2) {\n      this.searchHistory.unshift(query)\n      this.searchHistory = this.searchHistory.slice(0, 50) // Garder les 50 dernières\n      \n      this.popularQueries.set(query, (this.popularQueries.get(query) || 0) + 1)\n      \n      this.saveSearchHistory()\n    }\n  }\n\n  // Obtenir l'historique des recherches\n  getSearchHistory(): string[] {\n    return this.searchHistory.slice(0, 10)\n  }\n\n  // Obtenir les recherches populaires\n  getPopularSearches(): string[] {\n    return Array.from(this.popularQueries.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 10)\n      .map(([query]) => query)\n  }\n\n  // Sauvegarder l'historique\n  private saveSearchHistory() {\n    try {\n      localStorage.setItem('cityzenmag-search-history', JSON.stringify(this.searchHistory))\n      localStorage.setItem('cityzenmag-popular-queries', JSON.stringify(Array.from(this.popularQueries.entries())))\n    } catch (error) {\n      console.error('Erreur sauvegarde historique recherche:', error)\n    }\n  }\n\n  // Charger l'historique\n  private loadSearchHistory() {\n    try {\n      const history = localStorage.getItem('cityzenmag-search-history')\n      if (history) {\n        this.searchHistory = JSON.parse(history)\n      }\n\n      const popular = localStorage.getItem('cityzenmag-popular-queries')\n      if (popular) {\n        this.popularQueries = new Map(JSON.parse(popular))\n      }\n    } catch (error) {\n      console.error('Erreur chargement historique recherche:', error)\n    }\n  }\n\n  // Nettoyer l'historique\n  clearSearchHistory() {\n    this.searchHistory = []\n    this.popularQueries.clear()\n    localStorage.removeItem('cityzenmag-search-history')\n    localStorage.removeItem('cityzenmag-popular-queries')\n  }\n}\n\nexport const searchService = new SearchService()